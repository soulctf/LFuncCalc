

/* compute L(dd, 1-ss)

This version is for testing degree 2 totally real number fields with cone splitting

*/

/* code to generate totally positive fundamental units of bnf K (taken from PARI/GP User Guide)
*/
tpuexpo(K)=
{ my(M, S = bnfsignunit(K), [m,n] = matsize(S));
\\ m = K.r1, n = r1+r2-1
S = matrix(m,n, i,j, if (S[i,j] < 0, 1,0));
S = concat(vectorv(m,i,1), S); \\ add sign(-1)
M = matkermod(S, 2);
if (M, mathnfmodid(M, 2), 2*matid(n+1));
}

/* totally positive fundamental units of bnf K */
tpu(K)=
{ my(ex = tpuexpo(K)[,^1]); \\ remove ex[,1], corresponds to 1 or -1
my(v = concat(K.tu[2], K.fu));
[ nffactorback(K, v, c) | c <- ex];
}

{
candidate(mmm)=
   my(i,t,mmlll,m,mt,vv=matid(#mmm));
   m=mmm; 
   mt=m~; \\ want lattice generated by rows of m, but gp works with lattices generated by columns
   t=qflll(mt); 
   mmlll=mt*t; \\ cols of mmlll are now lll-reduced basis 
   for(i=1,#vv,
      \\ need to plug rows of vv into the different rows of mmlll
      if(testcandrows(mmlll,vv[i,]),
         \\ need to return a column vector 
         return( (vv[i,]*t^-1)~ );
         );
   );
   return(0);
}

\\ auxiliary routine to verify that a vector is a candidate 
{
testcandrows(m,v)=
   my(i,ans,d,mm);
   d=abs(matdet(m));
   for(i=1,#m,
      mm=m;
      mm[i,]=v;
      if(
         abs(matdet(mm))>=d,return(0)
        );
   );
   return(1);
}

\\ makes a vector primitive
{
   primvec(v)=
   my(d);
   d=content(v);
   if(d,return(v/d));
   return(v);
}

\\ returns a postive candidate for m.

{
   positivecandidate(m) =
   my(v = candidate(m),co,i);
   if(v == 0, return(0));
   co=matsolve(m,v);
   for(i=1,#co,
      if(co[i]<0,
	 v = v+m[,i];
	);
   );
   return(v);
}

\\ this can be used to verify that v is indeed a candidate of m.

\\ m = n by n integral matrix
\\ v = integral n (column) vector
\\ returns ans = vector of absolute vals of dets obtained by inserting v into each col
\\ ans[i] = abs(matdet([m_1, ..., v, ..., m_n]), with v in col i.  
{
   sig(m,v)=
   my(i,mm=m,n=matsize(m)[1],ans);
   ans=vector(n);
   for(i=1,n,
      mm[,i] = v;
      ans[i]=abs(matdet(mm));
      mm[,i] = m[,i];
   );
   return(ans);
}

{
lf(L, t, j, K) = 
    my(L = L, t = t,j = j);

    return(
        sum(i = 1, length(L), 
            if(i != j, 
                if(L[i] != 1, t[i] * L[i], 
                    Mod(t[i], K.pol)), 
                if(L[i] != 1, L[i], Mod(1, K.pol)))
        )
    );
}

/* Calculate shintani function for given parrallelogram mmi of area 1*/
{
shintani(cone, Rb, n, bc) = 
    my(Rb = Rb, cone=cone, mmi = Rb * cone, n = n, point_sum = 0, bc = bc, points, x_1, x_2, j, t, r, beta, ext);

    setrand(getwalltime());
    ext = random(10000000);

    /* This read call needs the directory you're putting the write files in */
    write(Str("/tmp/integral_points/", ext), Str(cone[,1], "\n", cone[,2], "\n", cone[,3]));

    /* This system call needs the path of the handler */
    system(Str("/home/soul/Desktop/ThesisCode/Degree3/handler", " ", ext));

    /* This read/rm call needs the directory you're putting the point files in */
    points = read(Str("/tmp/integral_points/", ext));
    system(Str("rm /tmp/integral_points/", ext));

    valid_points = List();
    p = [0, 0, 0];  


    for(piter = 1, length(points), 
        p[1] = polcoef(lift(((cone ^ -1) * [points[piter][1], points[piter][2], points[piter][3]]~)[1]), 0);
        p[2] = polcoef(lift(((cone ^ -1) * [points[piter][1], points[piter][2], points[piter][3]]~)[2]), 0);
        p[3] = polcoef(lift(((cone ^ -1) * [points[piter][1], points[piter][2], points[piter][3]]~)[3]), 0);

        if(bc == 0,
            if(p[3] <= 1 && p[3] > 0 && p[2] > 0 && p[2] <= 1 && p[1] >= 0 && p[1] < 1 && points[piter] != [0,0,0],
                listput(valid_points, [p[1], p[2], p[3]]);
            );,
            if(p[3] <= 1 && p[3] > 0 && p[2] >= 0 && p[2] < 1 && p[1] >= 0 && p[1] < 1 && points[piter] != [0,0,0],
                listput(valid_points, [p[1], p[2], p[3]]);
            );
        );
    ); 

    for(m_1 = 0, 3*n, 
        for(m_2 = 0, 3*n-m_1,
            m_3 = 3*n-m_1-m_2;
            base = 0;
            for(alpha = 0, n-1, 
                for(beta = 0, n-1-alpha,
                    charlie = n-1-alpha-beta;
                    for(x = 0, n-1,
                        for(y = 0, n-1-x,
                            z = n-1-x-y;
                            inner = (binomial(m_1-1, alpha) * binomial(m_2-1, beta) * binomial(m_3-1, charlie)) ;
                            inner *= binomial(m_1-1-alpha, x) * binomial(m_2-1-beta, y) * binomial(m_3-1-charlie, z);
                            inner *= ((mmi[,1][2] ^ alpha) * (mmi[,2][2] ^ beta) * (mmi[,3][2] ^ charlie) * (mmi[,1][3] ^ x) * (mmi[,2][3] ^ y) * (mmi[,3][3] ^ z) * (mmi[,1][1] ^ (m_1-1-alpha-x)) * (mmi[,2][1] ^ (m_2-1-beta-y)) * (mmi[,3][1] ^ (m_3-1-charlie-z))) + 
                                ((mmi[,1][1] ^ alpha) * (mmi[,2][1] ^ beta) * (mmi[,3][1] ^ charlie) * (mmi[,1][3] ^ x) * (mmi[,2][3] ^ y) * (mmi[,3][3] ^ z) * (mmi[,1][2] ^ (m_1-1-alpha-x)) * (mmi[,2][2] ^ (m_2-1-beta-y)) * (mmi[,3][2] ^ (m_3-1-charlie-z))) + 
                                ((mmi[,1][1] ^ alpha) * (mmi[,2][1] ^ beta) * (mmi[,3][1] ^ charlie) * (mmi[,1][2] ^ x) * (mmi[,2][2] ^ y) * (mmi[,3][2] ^ z) * (mmi[,1][3] ^ (m_1-1-alpha-x)) * (mmi[,2][3] ^ (m_2-1-beta-y)) * (mmi[,3][3] ^ (m_3-1-charlie-z)));
                            base += inner;
                        );
                    );
                );
            );
            base /= ((m_1!) * (m_2!) * (m_3!));

            for(piter = 1, length(valid_points),
                point_sum += base * subst(bernpol(m_1, x), x, valid_points[piter][1]) * subst(bernpol(m_2, x), x, valid_points[piter][2]) * subst(bernpol(m_3, x), x, valid_points[piter][3]);
            ); 
        );
    );
    point_sum *= ((n!) ^ 3) / 3;
    return(point_sum);
}

/* Splits cone into until determinate one*/
{
cone_helper(cone_im, Rb, n, K) = 
    my(cone_im = cone_im, Rb = Rb, n = n, cand = 0, curr = 0, K = K);
    /* Ignore cones of determinate 0, is artifact of LLL */
    if(abs(matdet(cone_im)) == 0, return(0));
    cand = positivecandidate(cone_im);
    if(cand != 0, 
        mm = cone_im;
        for(i=1, length(cone_im),
            mm[,i] = cand;
            curr += cone_helper(mm, Rb, n, K);
            mm[,i] = cone_im[,i];
        ),
        return(shintani(cone_im, Rb, n));
    );
    return(curr);
}

{
shintani_helper(K, id_inv, n) = 

    ret = 0;

    units = tpu(K);
    g = galoissplittinginit(K.pol).pol;
     /* Zb is the Z basis of the ideal, Rbi is the matrix that takes the Zbasis to the identity matrix basis
        multiplying the cone by Rbi takes it to new coordinates used for splitting
    */
    
    Zb = Mod(K.zk * idealhnf(K, id_inv), K.pol);
    L = bnfinit(subst(g, x, y));
    roots = nffactor(L, K.pol);
    root = -1 * (roots[1, ][1] - x);
    order = [1,3,5];

    if(poldegree(g) == 6,
        G = nfgaloisconj(L);
        Zby = vector(3, i, subst(Zb[i].pol, x, root));
        Rb = [
                Mod(1, L.pol), nfgaloisapply(L, G[order[1]], eval(Str(Zby[2].pol))), nfgaloisapply(L, G[order[1]], eval(Str(Zby[3].pol)));
                Mod(1, L.pol), nfgaloisapply(L, G[order[2]], eval(Str(Zby[2].pol))), nfgaloisapply(L, G[order[2]], eval(Str(Zby[3].pol)));
                Mod(1, L.pol), nfgaloisapply(L, G[order[3]], eval(Str(Zby[2].pol))), nfgaloisapply(L, G[order[3]], eval(Str(Zby[3].pol)))
        ];
        Rbi = Rb ^ -1;
        ,

        G = nfgaloisconj(K);	
        Rb = [
                Zb[1], Zb[2], Zb[3]; 
                nfgaloisapply(K, G[2], Zb[1]), nfgaloisapply(K, G[2], Zb[2]), nfgaloisapply(K, G[2], Zb[3]);
                nfgaloisapply(K, G[3], Zb[1]), nfgaloisapply(K, G[3], Zb[2]), nfgaloisapply(K, G[3], Zb[3])
        ];
        Rbi = Rb ^ -1;
    );
     
    
        
    
    bc = 0;
    forperm(length(Zb) - 1, perm, 
        fm = matrix(3, 3, i, j, 
            nfeltembed(K, prod(k = 1,j - 1,
                K.zk * units[perm[k]];
            ))[i]
        );

        em = matrix(2, 2, i, j, 
            log(nfeltembed(K, K.zk * units[j])[i])
        );

        w_sig = (permsign(perm) * sign(matdet(fm))) / (sign(matdet(em)));
 
        m = matrix(length(Zb), length(Zb), i, j, 
            vij = prod(k = 1, j-1, K.zk * units[perm[k]]);
            if(poldegree(g) == 6, 
		        if(vij == 1, vij = Mod(1, K.pol));
		        nfgaloisapply(L, G[order[i]], eval(Str(subst(vij, x, root).pol)))
		        ,
	            
                nfgaloisapply(K, G[i], vij)
	        );
        );
        ret += w_sig * shintani(Rbi * m, Rb, n, bc);
	    bc += 1;
    );
    
    return(ret);
}


{   
classgen(K, cyc, gen, id, n, debug=0) = 
    if(cyc == [],
        if(debug==1, print("Current Ideal: ", id););
        s +=  idealnorm(K, id) ^ (-(1-n)) * shintani_helper(K, idealinv(K, id), n);
        return();
    );

    for(i = 0, cyc[1]-1,
        curr_id = idealmul(K, id, idealpow(K, gen[1], i));
        classgen(K, cyc[^1], gen[^1], curr_id, n, debug);
    );
}


lfuncdeg3(pol, ss, flag=0, debug=0) =
{
    K = bnfinit(pol);
    na = bnfnarrow(K);

    if(na.no == 1,
        gen = [matid(length(K.zk))];
        cyc = [1];,
        gen = na.gen;
        cyc = na.cyc;
    );

    if(debug==1,print("Group Structure: ", gen, " " , cyc););
    
    s = 0;
    classgen(K, cyc, gen, matid(length(gen[1])), ss, debug);
    s *= -1 / (ss ^ 3);
    if(flag==1,print("Floating Point Approximation: ", lfun(pol, 1-ss)););
    return(polcoeff(s, 0));
}  
