/* compute L(dd, 1-ss)

This version is for testing degree 2 totally real number fields with cone splitting

*/

{
candidate(mmm)=
   my(i,t,mmlll,m,mt,vv=matid(#mmm), co,v, cand, best);
   m=mmm; 
   best = -1;
   cand = 0;
   mt=m~; \\ want lattice generated by rows of m, but gp works with lattices generated by columns
   t=qflll(mt); 
   mmlll=mt*t; \\ cols of mmlll are now lll-reduced basis 
   for(i=1,#vv,
      \\ need to plug rows of vv into the different rows of mmlll
      if(testcandrows(mmlll,vv[i,]),
         \\ need to return a column vector 
            v = (vv[i,]*t^-1)~;
            co=matsolve(m,v);
            for(i=1,#co,
                if(co[i]<0,
                v = v+m[,i];
                );
            );
            if(best == -1 || (v[1] ^2 + v[2]^ 2) < best, best = (v[1] ^2 + v[2]^ 2); cand = i);
         );
   );
   if(cand != 0, return( (vv[cand,]*t^-1)~ ));
    
   return(0);
}

\\ auxiliary routine to verify that a vector is a candidate 
{
testcandrows(m,v)=
   my(i,ans,d,mm);
   d=abs(matdet(m));
   for(i=1,#m,
      mm=m;
      mm[i,]=v;
      if(
         abs(matdet(mm))>=d,return(0)
        );
   );
   return(1);
}

\\ makes a vector primitive
{
   primvec(v)=
   my(d);
   d=content(v);
   if(d,return(v/d));
   return(v);
}

\\ returns a postive candidate for m.

{
   positivecandidate(m) =
   my(v = candidate(m),co,i);
   if(v == 0, return(0));
   co=matsolve(m,v);
   for(i=1,#co,
      if(co[i]<0,
	 v = v+m[,i];
	);
   );
   return(v);
}

\\ this can be used to verify that v is indeed a candidate of m.

\\ m = n by n integral matrix
\\ v = integral n (column) vector
\\ returns ans = vector of absolute vals of dets obtained by inserting v into each col
\\ ans[i] = abs(matdet([m_1, ..., v, ..., m_n]), with v in col i.  
{
   sig(m,v)=
   my(i,mm=m,n=matsize(m)[1],ans);
   ans=vector(n);
   for(i=1,n,
      mm[,i] = v;
      ans[i]=abs(matdet(mm));
      mm[,i] = m[,i];
   );
   return(ans);
}

/* Calculate shintani function for given parrallelogram mmi of area 1*/
{
shintani(cone, Rb, n) = 
    my(Rb = Rb, cone=cone, mmi = Rb * cone, n = n, point_sum = 0, points, x_1, x_2, j, t, r, beta, ext);
    
    setrand(getwalltime());
    ext = random(10000000);

    /* This read call needs the directory you're putting the write files in */
    write(Str("/tmp/integral_points/", ext), Str(cone[,1], "\n", cone[,2]));

    /* This system call needs the path of the handler */
    system(Str("/home/soul/Desktop/ThesisCode/handler", " ", ext));

    /* This read/rm call needs the directory you're putting the point files in */
    points = read(Str("/tmp/integral_points/", ext));
    system(Str("rm /tmp/integral_points/", ext));

    for(k = 0, 2 * n,
        j = 2 * n - k;
        r = 0;
        for(alpha = 0, n-1, 
            beta = n-1 - alpha;
            r += binomial(k-1, alpha) * binomial(j-1, beta)*(
                (mmi[,1][2]^alpha)*(mmi[,2][2]^beta)*(mmi[,1][1]^(k-1-alpha))*(mmi[,2][1]^(j-1-beta)) + 
                (mmi[,1][1]^alpha)*(mmi[,2][1]^beta)*(mmi[,1][2]^(k-1-alpha))*(mmi[,2][2]^(j-1-beta))
            );
        );

        for(i = 1, length(points), 
            x_1 = polcoef(lift(((mmi ^ -1) * (Rb * [points[i][1], points[i][2]]~))[1]), 0);
            x_2 = polcoef(lift(((mmi ^ -1) * (Rb * [points[i][1], points[i][2]]~))[2]), 0);
            if(x_2 < 1 && x_1 > 0,
                t = (subst(bernpol(k, z), z, x_1) * subst(bernpol(j, h), h, x_2)) / (((k!) * (j!)));
                point_sum += r * t;
            );
        ); 
    );

    return(point_sum);
}

/* Splits cone into until determinate one*/
{
cone_helper(cone_im, Rb, n, id) = 
    my(cone_im = cone_im, Rb = Rb, n = n, cand = 0, curr = 0, mm, l_ang, r_ang, m_ang);
    /* Ignore cones of determinate 0, is artifact of LLL */
    if(abs(matdet(cone_im)) == 0, return(0));
    if(abs(matdet(cone_im)) <= 100000, return(shintani(cone_im, Rb, n)));
    cand = candidate(cone_im);

    l_ang = acos((cand[1] * cone_im[,1][1] + cand[2] * cone_im[,1][2]) / (sqrt(cand[1] ^ 2 + cand[2] ^ 2) * sqrt(cone_im[,1][1] ^ 2 + cone_im[,1][2] ^ 2)));
    r_ang = acos((cand[1] * cone_im[,2][1] + cand[2] * cone_im[,2][2]) / (sqrt(cand[1] ^ 2 + cand[2] ^ 2) * sqrt(cone_im[,2][1] ^ 2 + cone_im[,2][2] ^ 2)));
    m_ang = acos((cone_im[,1][1] * cone_im[,2][1] + cone_im[,1][2] * cone_im[,2][2]) / (sqrt(cone_im[,1][1] ^ 2 + cone_im[,1][2] ^ 2) * sqrt(cone_im[,2][1] ^ 2 + cone_im[,2][2] ^ 2)));

    if(l_ang + r_ang > Pi(), 
        cand = -cand; 
        l_ang = acos((cand[1] * cone_im[,1][1] + cand[2] * cone_im[,1][2]) / (sqrt(cand[1] ^ 2 + cand[2] ^ 2) * sqrt(cone_im[,1][1] ^ 2 + cone_im[,1][2] ^ 2)));
        r_ang = acos((cand[1] * cone_im[,2][1] + cand[2] * cone_im[,2][2]) / (sqrt(cand[1] ^ 2 + cand[2] ^ 2) * sqrt(cone_im[,2][1] ^ 2 + cone_im[,2][2] ^ 2)));
    );

    if(cand != 0, 
        my(cones = vector(length(cone_im), i, cone_im));
        for(i=1, length(cone_im),
            cones[i][,i] = cand;
            if(r_ang > l_ang && r_ang > m_ang,
                if(i == 1, curr += cone_helper(cones[i], Rb, n), curr += -1 * cone_helper(cones[i], Rb, n));,
                if(l_ang > r_ang && l_ang > m_ang,
                    if(i == 1, curr += -1 * cone_helper(cones[i], Rb, n), curr += cone_helper(cones[i], Rb, n));,
                    curr += cone_helper(cones[i], Rb, n)
                );
            );
        );
    );
    return(curr);
}

{
shintani_helper(K, id_inv, n) = 
     /* Zb is the Z basis of the ideal, Rbi is the matrix that takes the Zbasis to the identity matrix basis
        multiplying the cone by Rbi takes it to new coordinates used for splitting
    */ 
    Zb = K.zk * idealhnf(K, id_inv);
    G = nfgaloisconj(K);
    aut = G[1];

    Rb = [Zb[1], Zb[2]; nfgaloisapply(K, aut, Zb)[1], nfgaloisapply(K, aut, Zb)[2]];
    Rbi = Rb ^ -1;
    

    /* Find cone of fundamental parallelogram and calculate image under transformation moving ideal lattice to Zbasis*/
    fu1 = vector(2, j,  subst( lift(K.fu[1]), x, real(polroots(K.pol)[j])) );
    if( fu1[1]>0 & fu1[2]>0,
        fu = K.fu[1];
        ,
        if( fu1[1]<0 & fu1[2]<0,
            fu = -K.fu[1];
            ,
            fu = K.fu[1]^2;
        );
    );

    fuc = nfgaloisapply(K, aut, fu);

    cone = Mat([1, fu; 1, fuc]);
    cone_im = Rbi * cone;
    
    return(cone_helper(cone_im, Rb, n));
}


classgen(K, cyc, gen, id, n, debug=0) = 
{   
    if(cyc == [],
        if(debug==1, print("Current Ideal: ", id););
        s += idealnorm(K, id) ^ (-(1-n)) * shintani_helper(K, idealinv(K, id), n);
        return();
    );

    for(i = 0, cyc[1]-1,
        curr_id = idealmul(K, id, idealpow(K, gen[1], i));
        classgen(K, cyc[^1], gen[^1], curr_id, n, debug);
    );
}



{
    lfuncdeg2(pol, ss, flag=0, debug=0) =    
    n = ss;

    K = bnfinit(pol, 1);
    na = bnfnarrow(K);

    if(na.no == 1,
        gen = [[1,0;0,1]];
        cyc = [1];,
        gen = na.gen;
        cyc = na.cyc;
    );

    if(debug==1,print("Group Structure: ", gen, " " , cyc););

    s = 0;
    classgen(K, cyc, gen, [1, 0; 0, 1], n, debug);
    s *= ((n-1)!) ^ 2 / 2;
    if(flag==1,print("Floating Point Approximation: ", lfun(pol, 1-ss)););
    return(polcoeff(s, 0));
}  
